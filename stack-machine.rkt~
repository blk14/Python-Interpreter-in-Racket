#lang racket
(require "opcodes.rkt")
(provide make-stack-machine)
(provide run-stack-machine)
(provide get-stack)
(provide get-varnames)
(provide get-consts)
(provide get-names)
(provide get-code)
(provide get-IC)
(provide empty-stack)
(provide make-stack)
(provide push)
(provide pop)
(provide top)

 (require racket/trace)


;; TODO 1:
;; Alegeți metoda de reprezentarea a unei stive.
;; Implementați:
(define empty-stack '())
(define (make-stack) empty-stack)

(define (push value stack) (cons value stack))
(define (top stack) (car stack))
(define (pop stack) (cdr stack))

;; TODO 2:
;; Alegeți metoda de reprezentare a unei mașini stivă.
;; Definiți make-stack-machine, acesta trebuie sa primeasca cele 4 segmente de date
;; Veți avea nevoie de o stivă pentru execuție și un counter ca să stiți
;; la ce instrucțiune sunteți.
(define (make-stack-machine stack co-varnames co-consts co-names co-code IC)
  (cons stack (cons co-varnames (cons co-consts (cons co-names (cons co-code (cons IC '())))))))

;; Definiți funcțiile `get-varnames`, `get-consts`, `get-names`,
;; `get-code`, `get-stack`, `get-IC` care primesc o mașina stivă și întorc
;; componenta respectivă

;; ex:
;; > (get-varnames (make-stack-machine empty-stack 'dummy-co-varnames (hash) (hash) (list) 0))
;; 'dummy-co-varnames
(define (get-varnames stack-machine) (cadr stack-machine))

;; ex:
;; > (get-consts (make-stack-machine empty-stack (hash) 'dummy-co-consts (hash) (list) 0))
;; 'dummy-co-consts
(define (get-consts stack-machine) (caddr stack-machine))

;; ex:
;; > (get-names (make-stack-machine empty-stack (hash) (hash) 'dummy-co-names (list) 0))
;; 'dummy-co-names
(define (get-names stack-machine) (cadddr stack-machine))

;; ex:
;; > (get-code (make-stack-machine empty-stack (hash) (hash) (hash) 'dummy-co-code 0))
;; dummy-co-code
(define (get-code stack-machine) (car (cddddr stack-machine)))

;; Întoarce stiva de execuție.
;; ex:
;; > (get-code (make-stack-machine 'dummy-exec-stack (hash) (hash) (hash) (list) 0))
;; dummy-exec-stack
(define (get-stack stack-machine) (car stack-machine))

;; Întoarce instruction counterul.
;; ex:
;; > (get-code (make-stack-machine empty-stack (hash) (hash) (hash) (list) 0))
;; 0
(define (get-IC stack-machine)  (car (cdr (cddddr stack-machine))))



(define symbols (list 'STACK 'CO-VARNAMES 'CO-CONSTS 'CO-NAMES 'CO-CODE 'INSTRUCTION-COUNTER))

;; TODO 3:
;; Definiți funcția get-symbol-index care gasește index-ul simbolului in listă.
(define (get-symbol-index symbol)
  (let iter ([mySymbols symbols]
             [symbol symbol]
             [result 0])
             (if (equal? symbol (car mySymbols))
                 result
                 (iter (cdr mySymbols) symbol (+ result 1)))))

;; Definiți funcția update-stack-machine care intoarce o noua mașina stivă
;; înlocuind componenta corespondentă simbolului cu item-ul dat în paremetri.
;; > (get-varnames (update-stack-machine "new-varnames" 'CO-VARNAMES stack-machine))
;; "new-varnames"
;; > (get-varnames (update-stack-machine "new-names" 'CO-NAMES stack-machine))
;; "new-names"
(define (update-stack-machine item symbol stack-machine)
  (let iter ([item item]
             [symbol symbol]
             [stack-machine stack-machine]
             [cur_iteration 0])
    (if (eq? cur_iteration 5)
        (if (eq? (get-symbol-index symbol) 5)
            (cons item '())
            (cons (top stack-machine) '()))
        (if (eq? (get-symbol-index symbol) cur_iteration)
            (cons item (iter item symbol (pop stack-machine) (+ cur_iteration 1)))
            (cons (top stack-machine) (iter item symbol (pop stack-machine) (+ cur_iteration 1)))))))


;; Definiți funcția push-exec-stack care primește o masină stivă și o valoare
;; și intoarce o noua mașina unde valoarea este pusă pe stiva de execuție
(define (push-exec-stack value stack-machine)
  (push (value stack-machine)))

;;  Definiți funcția pop-exec-stack care primește o masină stivă
;;  și intoarce o noua mașina aplicând pop pe stiva de execuție.
(define (pop-exec-stack stack-machine)
  (pop stack-machine))

;; TODO 4:
;; Definiți funcția run-stack-machine care execută operații pană epuizează co-code.

(define (get-elem-from-pos i map)
  (hash-ref list i))

(define (add-on-pos i list elem)
   (hash-set list i elem))

(define (multy-update items symbols stack-machine)     ; vreau sa fac update-uri la mai multe liste din stack-machine
  (if (equal? (length items) 1)
      (update-stack-machine (car items) (car symbols) stack-machine)
      (multy-update (cdr items) (cdr symbols) (update-stack-machine (car items) (car symbols) stack-machine))))
      

(define (run-stack-machine stack-machine)
  (if (null? (get-code stack-machine))
      stack-machine
      (cond
        ((equal? (car (car (get-code stack-machine))) 'LOAD_CONST) ; se verifica pt LOAD_CONST
         (run-stack-machine (multy-update 
          (list (push (hash-ref (get-consts stack-machine) (cdr (car (get-code stack-machine))))   ;pun pe stiva lui stack-machine elem de la pozitia
                      (get-stack stack-machine))                                                    ;data de al 2 lea param al elem din co_code
            (cdr (get-code stack-machine)))
          (list'STACK 'CO-CODE) stack-machine)))
                                                                                            
        ((equal? (car (car (get-code stack-machine))) 'LOAD_FAST)
         (run-stack-machine (multy-update                            ;reapelez actualizand stiva din stack-machine
         (list (push (hash-ref (get-varnames stack-machine) (cdr (car (get-code stack-machine))))
                     (get-stack stack-machine))
               (cdr (get-code stack-machine)))
         (list'STACK 'CO-CODE) stack-machine)))
        
        ((equal? (car (car (get-code stack-machine))) 'STORE_FAST)
         (run-stack-machine (multy-update
            (list (pop (get-stack stack-machine))                       ;pt multy update pun in lista items 
                  (hash-set (get-varnames stack-machine)        ;stiva cu pop, map-ul varnames cu update
                            (cdr (car (get-code stack-machine)))        
                            (top (get-stack stack-machine)))
                  (cdr (get-code stack-machine)))                       ; si co code
            
                            (list 'STACK 'CO-VARNAMES 'CO-CODE) stack-machine)))       ; setez simbolurile

        ;incercare test 6
        ((equal? (car (car (get-code stack-machine))) 'LOAD-GLOBAL)
         (run-stack-machine (update-stack-machine (cdr (get-code stack-machine)) 'CO-CODE stack-machine)))
        
        (else stack-machine))))












                                              
         ; (trace run-stack-machine)

;(run-stack-machine (make-stack-machine empty-stack (hash 0 'a 1 'b) (hash 0 0 1 2 2 3) (hash) '((LOAD_CONST . 1) (STORE_FAST . 0)
                                                                                      ; (LOAD_CONST . 2) (STORE_FAST . 1)
                                                                                      ; (LOAD_CONST . 0)
                                                                                       ;(RETURN-VALUE)) 0))

;(run-stack-machine (make-stack-machine empty-stack '() '(0 2) '() '((LOAD_CONST . 1) (RETURN-VALUE)) 0))

;(run-stack-machine (make-stack-machine empty-stack '('a 'b 'c 'd) '(0 2 3 4 5) '() '((LOAD_CONST . 1) (STORE_FAST . 0)
                                                                                      ; (LOAD_CONST . 2) (STORE_FAST . 1)
                                                                                       ;(LOAD_CONST . 3) (STORE_FAST . 2)
                                                                                      ; (LOAD_CONST . 4) (STORE_FAST . 3)
                                                                                      ; (LOAD_CONST . 0)
                                                                                      ; (RETURN-VALUE)) 0))
